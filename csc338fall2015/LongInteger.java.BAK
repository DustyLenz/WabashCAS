/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package csc338fall2015;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.ListIterator;

/**
 * Multiprecision integer class
 *
 * @author turnerw
 */
public class LongInteger {

    // Declare static members first so can use later
    private final static Integer radix = 10;
    public static LongInteger ZERO = LongInteger.valueOf(0);
    public static LongInteger ONE = LongInteger.valueOf(1);
    public static LongInteger TEN = LongInteger.valueOf(10);
    private static LongInteger modulus = LongInteger.ZERO;
    // Non-static members
    private ArrayList<Integer> digits;
    private boolean positive;

    /**
     * Default constructor.
     *
     */
    public LongInteger() {
        this.digits = new ArrayList<Integer>();
        this.positive = true;
    }

    /**
     * Copy constructor
     *
     * @param n LongInteger to copy
     */
    public LongInteger(LongInteger n) {
        this.digits = new ArrayList<Integer>(n.digits);
        this.positive = n.positive;

        // Minimize length of result
        this.minimizeLength();

    }

    /**
     * Constructor from list of digits and a the sign.
     *
     * @param digits List of digits
     * @param positive Is it positive?
     */
    public LongInteger(List<Integer> digits, boolean positive) {
        this.digits = new ArrayList<Integer>(digits);
        this.positive = positive;

        // Minimize length of result
        this.minimizeLength();
    }

    /**
     * Construct a positive integer from a list of digits.
     *
     * @param digits List of digits
     */
    public LongInteger(List<Integer> digits) {
        this(digits, true);
    }

    /**
     * Constructor from array of digits and a the sign.
     *
     * @param digits Array of digits
     * @param positive Is it positive?
     */
    public LongInteger(Integer[] digits, boolean positive) {
        this.positive = positive;
        this.digits = new ArrayList<Integer>();
        for (int i = 0; i < digits.length; ++i) {
            this.digits.add(digits[i]);
        }

        // Minimize length of result
        this.minimizeLength();
    }

    /**
     * Construct a positive integer from a array of digits.
     *
     * @param digits Array of digits
     */
    public LongInteger(Integer[] digits) {
        this(digits, true);
    }

    /**
     * Constructor from array of digits and a the sign.
     *
     * @param digits Array of digits
     * @param positive Is it positive?
     */
    public LongInteger(int[] digits, boolean positive) {
        this.positive = positive;
        this.digits = new ArrayList<Integer>();
        for (int i = 0; i < digits.length; ++i) {
            this.digits.add(new Integer(digits[i]));
        }

        // Minimize length of result
        this.minimizeLength();
    }

    /**
     * Construct a positive integer from a array of digits.
     *
     * @param digits Array of digits
     */
    public LongInteger(int[] digits) {
        this(digits, true);
    }

    /**
     * Construct a LongInteger from a string. This will take a value based on
     * the string before the first nondigit (with the exception of an initial +
     * or -).
     *
     * @param str
     */
    public LongInteger(String str) {
        this.digits = new ArrayList<Integer>();
        this.positive = true;

        // Iterate through position in the string
        int pos = 0;
        char chr = ' ';

        // Skip initial whitespace
        while (pos < str.length() && Character.isWhitespace(chr = str.charAt(pos))) {
            ++pos;
        }

        // All whitespace?
        if (pos == str.length()) {
            System.out.println("At end!");
            return;
        }

        // Stopped at sign?
        if (chr == '-' || chr == '+') {
            this.positive = (chr == '+');

            ++pos; // Increment position

            // Skip any more whitespace
            while (pos < str.length() && Character.isWhitespace(chr = str.charAt(pos))) {
                ++pos;
            }
        }

        // Look now only at (decimal) digits
        while (pos < str.length() && Character.isDigit(chr = str.charAt(pos))) {
            this.digits.add(Character.getNumericValue(chr));
            ++pos;
        }

        // Now done with all digits, so reverse and convert base
        Collections.reverse(this.digits);
        this.digits = LongInteger.convertBase(this.digits, 10, radix);
        this.minimizeLength();
    }

    /**
     * Create a LongInteger from a string.
     *
     * @param str
     * @return
     */
    public static LongInteger valueOf(String str) {
        return new LongInteger(str);
    }

    /**
     * Create a LongInteger from a value.
     *
     * @param val
     * @return
     */
    public static LongInteger valueOf(int val) {
        LongInteger result = new LongInteger();

        // Negative?
        if (val < 0) {
            result.positive = false;
            val *= -1;
        }

        // Russian peasant method to find digits
        Integer quo = new Integer(val);
        Integer rem = new Integer(0);

        while (quo > 0) {
            result.digits.add(quo % LongInteger.radix);
            quo /= LongInteger.radix;
        }

        // Minimize length of result
        result.minimizeLength();

//  // Modular arithmetic?
//  if( LongInteger.modulus.compare( LongInteger.ZERO ) > 0 )
//   result = result.remainder( LongInteger.modulus );

        // Done
        return result;
    }

    public static Integer radix() {
        return LongInteger.radix;
    }

    public static LongInteger modulus() {
        throw new UnsupportedOperationException("not yet supported");
    }

    public static LongInteger modulus(LongInteger mod) {
        throw new UnsupportedOperationException("not yet supported");
    }

    /**
     * Using modular arithmetic? Checks without using the compare or equals
     *
     * @return
     */
    public static boolean modular() {
        throw new UnsupportedOperationException("not yet supported");
    }

    /**
     * Reduce modulo the static modulus This method DOES NOT change this!
     *
     * @return
     */
    public LongInteger modularReduction() {
        throw new UnsupportedOperationException("not yet supported");
    }

    /**
     * Minimizes the size of the digit list so the last (mist significant)
     * digits is nonzero.
     */
    private void minimizeLength() {
        // Remove leading zero digits
        int i = this.digits.size();
        while (i > 0 && 0 == this.digits.get(--i)) {
            this.digits.remove(i);
        }

        // Zero always positive
        if (this.digits.isEmpty()) {
            this.positive = true;
        }

    }

    /**
     * Access list of digits
     *
     * @return
     */
    public List<Integer> digits() {
        return this.digits;
    }

    /**
     * Is this positive?
     *
     * @return
     */
    public boolean positive() {
        return this.positive;
    }

    public int length() {
        this.minimizeLength();
        return this.digits.size();
    }

    /**
     * Compare two LongIntegers Returns 1, 0, or -1 if this is greater than,
     * equal to, or less than x, respectively.
     *
     * This method ignores modular arithmetic and compares the actual
     * representations as integers.
     *
     * @param x
     * @return
     */
    public int compare(LongInteger x) {
        // Ensure corrent form (minimal length)
        this.minimizeLength();
        x.minimizeLength();

        // Quick sign test first
        if (this.positive != x.positive) {
//   System.out.println("Different sign" + this.positive );
            if (this.positive) {
                return 1;
            } else {
                return -1;
            }
        }

        // Same sign, so compare digits

        // Make flag for ease in return statements
        int greater = 1;
        if (!this.positive) {
            greater = -1;
        }
//  System.out.println("greater = " + greater);

        // Compare lengths
//  System.out.printf("this.length = %d, x.length = %d\n", this.length(), x.length() );
        if (this.length() > x.length()) {
            return greater;
        } else if (this.length() < x.length()) {
            return -greater;
        }

//  System.out.println( "Same length");

        // Same length, so must compare individual digits, starting with most significant
        int length = this.length();
        Integer thisDigit;
        Integer xDigit;
        for (int i = length - 1; i >= 0; --i) {
            thisDigit = this.digits.get(i);
            xDigit = x.digits.get(i);
//   System.out.printf("i = %d, thisDigits = %s, xDigit = %s\n", i, thisDigit.toString(), xDigit.toString() );
            if (thisDigit > xDigit) {
                return greater;
            } else if (thisDigit < xDigit) {
                return -greater;
            }
        }

        // All digits equal
        return 0;
    }

    /**
     * Checks if two LongIntegers are equal. This method uses the modular
     * arithmetic, and it returns true whenever the two LongIntegers are
     * congruent modulo the modulus. Use compare if you want to compare their
     * actual integer representations.
     *
     * @param x
     * @return whether the two LongIntegers are congruent
     */
    public boolean equals(LongInteger x) {
//  System.out.printf( "equals: %s: %s == %s; %s\n", 0 == this.compare(x), this, x, this.subtract( x ).digits );
//  if( LongInteger.modular() )
//   return 0 == this.subtract( x ).compare( LongInteger.ZERO );
//  else
        return 0 == this.compare(x);
    }

    /**
     * Add a LongInteger with the same sign.
     *
     * This method ignores the modulus and always computes in the integers.
     *
     * @param x LongInteger with the same sign as this
     * @return
     */
    private LongInteger addSameSign(LongInteger x) {
        //Set sign
        boolean sign = this.positive();
        ArrayList<Integer> tempList = new ArrayList<Integer>();
        int size = this.digits.size();
        boolean carry = false;
        //Pad lesser value with zeros
        if (x.digits.size() < size) { //this is bigger than x
            int difference = size - x.digits.size();
            //Append difference in size worth of zeros onto shorter list
            x.digits.addAll(new ArrayList<Integer>(Collections.nCopies(difference, 0)));
        } else if (x.digits.size() > size) {
            //this is smaller than x
            int difference = x.digits.size() - size;
            this.digits.addAll(new ArrayList<Integer>(Collections.nCopies(difference, 0)));
            size = x.digits.size();
        } else {//lambda(x) = lambda(this), nothing special needs to be done.
        }
        //Increment through each digit
        for (int i = 0; i < size; i++) {
            int tempAdder = this.digits.get(i) + x.digits.get(i);

            if (carry) {//Add one if carry flag
                tempAdder++;
            }
            carry = false;
            //Set carry
            if (tempAdder > 9) {
                carry = true;
            }
            tempList.add(tempAdder % 10);
        }
        if (carry) {
            tempList.add(1);
        }
        return new LongInteger(tempList, sign);
    }

    /**
     * Subtract a LongInteger with the same sign.
     *
     * If the leading digit in the result is negative, we still need to reverse
     * the rest.
     *
     * This method ignores the modulus and always computes in the integers.
     *
     * @param x LongInteger with the same sign as this
     * @return
     */
    private LongInteger subtractSameSign(LongInteger x) {
        //Check sign of what we're substracting
        boolean sign = this.positive();
        ArrayList<Integer> tempList = new ArrayList<Integer>();
        int size = this.digits.size();
        boolean carry = false;
        if (x.digits.size() < size) { //this is bigger than x
            int difference = size - x.digits.size();
            //Append difference in size worth of zeros onto shorter list
            x.digits.addAll(new ArrayList<Integer>(Collections.nCopies(difference, 0)));
        } else if (x.digits.size() > size) {
            //this is smaller than x
            int difference = x.digits.size() - size;
            this.digits.addAll(new ArrayList<Integer>(Collections.nCopies(difference, 0)));
            size = x.digits.size();
        } else {//lambda(x) = lambda(this), nothing special needs to be done.
        }
        for (int i = 0; i < size; i++) {
            int tempAdder = this.digits.get(i) - x.digits.get(i);
            if (carry) {
                tempAdder--;
            }
            carry = false;

            if (tempAdder < 0) {
                carry = true;
                tempList.add(tempAdder + 10);
            } else {
                tempList.add(tempAdder);
            }
        }
        if (carry) {
            sign = !sign;
            tempList.set(0, 10 - tempList.get(0));
            for (int i = 1; i < size; i++) {
                tempList.set(i, 9 - tempList.get(i));
            }
        }
        return new LongInteger(tempList, sign);
    }

    /**
     * Computer the radix complement of this LongIntger. This method is used in
     * the subtractSameSign to change the sign of the difference.
     *
     * @return
     */
    private LongInteger radixComplement() {
        // Create storage for the result
        LongInteger result = new LongInteger();

        // Reverse the sign.
        result.positive = !this.positive;

        // Starting with least significant digit, do the conversion
        ListIterator<Integer> itr = this.digits.listIterator();
        Integer newDigit = Integer.valueOf(0);

        // Put trailing zeros on the result
        while (itr.hasNext() && 0 == (newDigit = itr.next())) {
            result.digits.add(newDigit);
        }

        // If not all zero, now at first nonzero digit.
        if (newDigit != 0) {
            result.digits.add(LongInteger.radix - newDigit);
        }

        // Now convert rest of digits for result
        Integer radixMinusOne = LongInteger.radix - 1;
        while (itr.hasNext()) {
            result.digits.add(radixMinusOne - itr.next());
        }

        // Done
        return result;

    }

    /**
     * Addition Does not change this.
     *
     * @param x Other operand
     * @return Result as new LongInteger
     */
    public LongInteger add(LongInteger x) {
        // Decide which helper function to use
        LongInteger result;
        if (this.positive == x.positive) {
            result = this.addSameSign(x);
        } else {
            result = this.subtractSameSign(x);
        }

//  // Modular arithmetic?
//  if( LongInteger.modular() )
//   result = result.remainder( LongInteger.modulus );

        // Done
        return result;
    }

    /**
     * Subtraction Does not change this.
     *
     * @param x Other operand
     * @return Result as new LongInteger
     */
    public LongInteger subtract(LongInteger x) {
        return this.add(x.changeSign());
    }

    /**
     * "Scalar" multiplication. This method is written in parallel to that of a
     * polynomial to aid in the public methods.
     *
     * @param x Integer "scalar" by which to multiply
     * @return
     */
    private LongInteger multiply(Integer x) {
        int carry = 0;
        ArrayList<Integer> returnList = new ArrayList<Integer>();
        for (int i = 0; i < this.length(); i++) {
            int temp = (this.digits.get(i) * x) + carry;
            returnList.add(temp % 10);
            carry = temp / 10;
        }
        if (carry > 0) {
            returnList.add(carry);
        }
        return new LongInteger(returnList);
    }

    /**
     * Multiplication Does not change this.
     *
     * @param x Other operand
     * @return Result as new LongInteger
     */
    public LongInteger multiply(LongInteger x) {
        boolean sign = (this.positive == x.positive);
        LongInteger accumulator = LongInteger.valueOf(0);

        for (int i = 0; i < x.length(); i++) {
            ArrayList<Integer> tempList = new ArrayList<Integer>();
            tempList.addAll(new ArrayList<Integer>(Collections.nCopies(i, 0)));
            tempList.addAll(this.multiply(x.digits.get(i)).digits);
            accumulator = accumulator.add(new LongInteger(tempList));
        }
        accumulator.positive = sign;
        return accumulator;
    }

    private Integer leadingDigit() {
        this.minimizeLength();

        if (this.digits.isEmpty()) {
            return Integer.valueOf(0);
        } else {
            return this.digits.get(this.digits.size() - 1);
        }
    }

    /**
     * Multiply this by a power of the radix
     *
     * @param power
     * @return
     */
    private LongInteger shift(int power) {
        int tempRadix = radix;
        LongInteger tempReturn = this;
        for(int i = 0; i < power ;i++){
            tempReturn = tempReturn.multiply(tempRadix);
        }
        return tempReturn;
    }

    /**
     * Division Does not change this.
     *
     * @param x Other operand
     * @return Result as new LongInteger
     */
    public LongInteger divide(LongInteger x) {
//  if( LongInteger.modulus.compare( LongInteger.ZERO ) == 0 )
        return this.divideAndRemainder(x)[0];
//  else
//   return this.divideMod(x);
    }

    /**
     * Remainder after division Does not change this.
     *
     * @param x Other operand
     * @return Result as new LongInteger
     */
    public LongInteger remainder(LongInteger x) {
        return this.divideAndRemainder(x)[1];
    }

    /**
     * Division returning both quotient and remainder Does not change this.
     *
     * This method ignores the modulus and always computes in the integers.
     *
     * @param b Other operand
     * @return Array with quotient first and then remainder
     */
    public LongInteger[] divideAndRemainder(LongInteger x) {
      //Check for divide by zero
      if(x.equals(LongInteger.ZERO)){
          throw new java.lang.ArithmeticException("Divide by zero");
      }
      boolean sign = (this.positive == x.positive);
      LongInteger[] returnArray = new LongInteger[2];
      ArrayList<Integer> returnDigitList = new ArrayList<Integer>();      
      ArrayList<Integer> quotient = new ArrayList<Integer>();
      if(this.abs().compare(x.abs()) < 0){
          //System.out.println("Instant exit");
          returnArray[0] = LongInteger.valueOf(0);
          returnArray[1] = this;
          return returnArray;
      }
      
      LongInteger denominator = new LongInteger(x);
      LongInteger numerator = new LongInteger(this);
      
      denominator.positive = true;
      numerator.positive = true;
      
      int denomLeadingDigit = denominator.digits.get(x.length()-1);
      for(int i = 0; i < numerator.length(); i++){
          quotient.add(0, numerator.digits.get(numerator.length()-i -1));
          //System.out.println("quotient: " + (new LongInteger(quotient)).toString());
          int numLeadingDigit = quotient.get(quotient.size()-1);
          //System.out.println("Num Leading " + numLeadingDigit);
          //System.out.println("Denom Leading " + denomLeadingDigit);
          int trialDigit= 9;
          /*int trialDigit = numLeadingDigit/ denomLeadingDigit;
          if(trialDigit == 0){
              trialDigit = 9;
          }*/
          //System.out.println("Test Trial Digit: " + trialDigit);
          LongInteger tempQuotient = (new LongInteger(quotient)).subtract(denominator.multiply(trialDigit));
          //System.out.println("tempQuotient: " + tempQuotient.toString());
          while(!tempQuotient.positive){
              if(trialDigit == 0){
                  tempQuotient = new LongInteger(quotient);
                  break;
              }
              tempQuotient = tempQuotient.add(denominator);
              //System.out.println("tempQuotient in Loop: " + tempQuotient.toString());
              trialDigit--;
          }
          quotient = tempQuotient.digits;
         // System.out.println("Adding: " + trialDigit);
          returnDigitList.add(0, trialDigit);
      }
      //System.out.println("Quotient Out of Loop: " + quotient);
      returnArray[0] = new LongInteger(returnDigitList, sign);
      returnArray[1] = new LongInteger(quotient);
      if(!sign){
          returnArray[1] = returnArray[1].changeSign();
      }
      
      return returnArray;
    }

    /**
     * Division absolute values returning both quotient and remainder Does not
     * change this.
     *
     * This method ignores the modulus and always computes in the integers.
     *
     * @param b Other operand
     * @return Array with quotient first and then remainder
     */
    private LongInteger[] divideAndRemainderAbsolute(LongInteger x) {
        throw new UnsupportedOperationException("not yet supported");
    }

    /**
     * Negation Does not change this.
     *
     * @return Result as new LongInteger
     */
    private LongInteger changeSign() {
//  if( LongInteger.modular() )
//   return LongInteger.modulus.subtractSameSign( this );
//  else
        // Return new LongInteger with same digits and opposite sign
        return new LongInteger(this.digits, !this.positive);
    }

    /**
     * Negation Does not change this.
     *
     * @return Result as new LongInteger
     */
    public LongInteger negate() {
        LongInteger result = this.changeSign();

//  if( LongInteger.modular() )
//   result = result.remainder( LongInteger.modulus );
////  else
//   // Return new LongInteger with same digits and opposite sign
        return result;
    }

    /**
     * Absolute value of this
     *
     * @return
     */
    public LongInteger abs() {
        LongInteger result = new LongInteger(this);
        result.positive = true;
        return result;
    }

    /**
     * Multiplicative inverse Does not change this.
     *
     * @return Result as new LongInteger
     */
    public LongInteger inverse() {
        throw new UnsupportedOperationException("not yet supported");
    }

    @Override
    public String toString() {

        // Ensure minimum length
//  this.minimizeLength();

        // If no digits, it is zero
        if (this.digits.isEmpty()) {
            return "0";
        }

        // If have digits, build a string from list of decimal digits.
        StringBuilder result = new StringBuilder();

        // Positive or negative?
        if (!positive) {
            result.append('-');
        }

        // Convert to decimal (not efficient)
        List<Integer> newDigits = LongInteger.convertBase(this.digits, LongInteger.radix, new Integer(10));

        // Reverse of ease of printing
        Collections.reverse(newDigits);

        // Add to result
        ListIterator<Integer> itr = newDigits.listIterator();
        while (itr.hasNext()) {
            result.append(itr.next().toString());
        }

        return result.toString();
    }

    /**
     * Convert a list of digits from one base to another
     *
     * @param digits
     * @param fromRadix
     * @param toRadix
     * @return
     */
    public static ArrayList<Integer> convertBase(ArrayList<Integer> digits, Integer fromRadix, Integer toRadix) {
        ArrayList<Integer> result = new ArrayList<Integer>();

        // Reverse digits for ease in conversion
        ArrayList<Integer> revDigits = new ArrayList<Integer>(digits);  // Copy
        Collections.reverse(revDigits); // Reverse

        // Russian Peasant Method
        while (!revDigits.isEmpty()) {
            ArrayList<Integer> newRevDigits = new ArrayList<Integer>(); // Temporary storage
            ListIterator<Integer> itr = revDigits.listIterator();
            Integer quo;
            Integer rem = new Integer(0);

            // Divide by toRadix
            while (itr.hasNext()) {
                quo = itr.next() + rem * fromRadix;
                newRevDigits.add(quo / toRadix);
                rem = quo % toRadix;  // Carry the remainder
            }

            // Remainder is next digit of the result
            result.add(rem);

            // Prepare for next iteration
            revDigits = newRevDigits;

            // Eliminate leading zeros
            int i = 0;
            while (i < revDigits.size() && 0 == revDigits.get(i)) {
                ++i;
            }
            revDigits.subList(0, i).clear();
        }

        return result;
    }

    /**
     * The traditional Extended Euclidean Algorithm. Computes the GCD and
     * corresponding coefficients of this and x via the traditional algorithm
     * and returns an array of three LongIntegers. [0] is a GCD [1] is the
     * coefficient corresponding to this [2] is the coefficient corresponding to
     * x
     *
     * The computation is always done in the integers, not in modular
     * arithmetic.
     *
     * @param x
     * @return
     */
    public LongInteger[] traditionalEEA(LongInteger x) {
        throw new UnsupportedOperationException("not yet supported");
    }

    /**
     * The Extended Euclidean Algorithm. Computes the GCD and corresponding
     * coefficients of this and x via the Extended Euclidean algorithm and
     * returns an array of three LongIntegers. [0] is the GCD [1] is the
     * coefficient corresponding to this [2] is the coefficient corresponding to
     * x
     *
     * The computation is always done in the integers, not in modular
     * arithmetic.
     *
     * @param x
     * @return
     */
    public LongInteger[] EEA(LongInteger x) {
        throw new UnsupportedOperationException("not yet supported");
    }

    /**
     * Greatest common divisor
     *
     * @param x
     * @return
     */
    public LongInteger gcd(LongInteger x) {
        return this.traditionalEEA(x)[0];
    }

    /**
     * Modular division Does not change this.
     *
     * @param x Other operand
     * @return Result as new LongInteger
     */
    private LongInteger divideMod(LongInteger x) {
        throw new UnsupportedOperationException("not yet supported");
    }

    /**
     * Raise to a power Does not change this.
     *
     * @param l Power to raise this to
     * @return Result as new LongInteger
     */
    public LongInteger pow(LongInteger l) {
        throw new UnsupportedOperationException("not yet supported");
    }

    /**
     * Evaluate the integer at a series of moduli
     *
     * @param m Moduli at which to evaluate the integer
     * @return Array of values
     */
    public LongInteger[] evaluate(LongInteger[] m) {
        throw new UnsupportedOperationException("not yet supported");
    }

    /**
     * Chinese Remainder Algorithm
     *
     * This algorithm assumes the moduli are all pair-wise co-prime.
     *
     * @param v Array of values at moduli
     * @param m Array of moduli
     * @return
     */
    public static LongInteger cra(LongInteger[] v, LongInteger[] m) {
        throw new UnsupportedOperationException("not yet supported");
    }

    /**
     * Multiply by LongInteger x via Karatsuba algorithm
     *
     * @param x Other operand
     * @return Result as new LongInteger
     */
    public LongInteger karatsuba(LongInteger x) {
        throw new UnsupportedOperationException("not yet supported");
    }

    /**
     * p-adic inversion using Newton iteration. Invert this modulo p^l given a
     * starting solution g0
     *
     * @param p an arbitrary LongInteger
     * @param l a power of p
     * @param g0 the inverse of this modulo p
     * @return
     */
    public LongInteger inversion(LongInteger p, int l, LongInteger g0) {
        throw new UnsupportedOperationException("not yet supported");
    }
}
