/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package csc338fall2015;

//import java.math.LongInteger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

/** Single variable polynomial implemented as an array of coefficients.
 *
 * @param R Coefficient ring
 *
 * @author turnerw
 */
public class LongIntegerPolynomial {

 // Declare first so can use later
 public static LongIntegerPolynomial ZERO = LongIntegerPolynomial.valueOf(0);
 public static LongIntegerPolynomial ONE = LongIntegerPolynomial.valueOf(1);
 public static LongIntegerPolynomial X = LongIntegerPolynomial.valueOf(1).shift(1);

 /** Coefficient array implemented as an array of ring elements.
  *
  */
 public ArrayList<LongInteger> coeffs;

 /** Modulus for polynomial modular arithmetic (extension field);
  * 
  */
// private static LongIntegerPolynomial modulus = LongIntegerPolynomial.valueOf( 0 );
 private static LongIntegerPolynomial modulus = LongIntegerPolynomial.ZERO;

 
 /** Default constructor.
  * Creates an empty polynomial with no non-zero coefficients.
  */
 public LongIntegerPolynomial() {
  this.coeffs = new ArrayList<LongInteger>();
 }

 /** Copy constructor
  *
  * @param f Polynomial to copy
  */
 public LongIntegerPolynomial(LongIntegerPolynomial f) {
  this.coeffs = new ArrayList<LongInteger>(f.coeffs);
  this.ensureLeadingCoefficient();
 }

 /** Constructor from a coefficient list.
  *
  * @param c List of coefficients of the polynomial to construct.
  */
 public LongIntegerPolynomial(List<LongInteger> c) {
  this.coeffs = new ArrayList<LongInteger>(c);
  this.ensureLeadingCoefficient();
 }

 /** Constructor from an array of coefficients.
  *
  * @param ints Array of coefficients of the polynomial to construct.
  */
 public LongIntegerPolynomial( LongInteger[] ints ) {
  this.coeffs = new ArrayList<LongInteger>();
  for( int i = 0; i < ints.length; ++i )
   this.coeffs.add( ints[i] );

  this.ensureLeadingCoefficient();
 }

 /** Create a LongIntegerPolynomial from a value.
  *
  * @param val
  * @return
  */
 public static LongIntegerPolynomial valueOf(LongInteger val) {
  LongIntegerPolynomial result = new LongIntegerPolynomial();
  
  // Put on constant term only
  if( !val.equals( LongInteger.ZERO ) )
   result.coeffs.add( val );
 
  // Done
  return result;
 }
 
 /** Create a LongIntegerPolynomial from a value.
  *
  * @param val
  * @return
  */
 public static LongIntegerPolynomial valueOf(int val) {
  LongIntegerPolynomial result = new LongIntegerPolynomial();
  
  // Put on constant term only
  if( val != 0 )
   result.coeffs.add( LongInteger.valueOf( val ) );
 
  // Done
  return result;
 }
 
 public static LongIntegerPolynomial modulus() {   
   throw new UnsupportedOperationException("not yet supported");
 }

 public static LongIntegerPolynomial modulus( LongIntegerPolynomial mod ) {
  throw new UnsupportedOperationException("not yet supported");
 }

 /** Using modular arithmetic?
  * Checks without using the compare or equals
  * 
  * @return 
  */
 public static boolean modular() {
  return false;
 }
 
 
 /** Minimizes the size of the coefficient list so the leading coefficient
  * is the last entry in the array.
  */
 private void ensureLeadingCoefficient() {
  int i = this.coeffs.size();

  while( i > 0 && this.coeffs.get( --i ).equals( LongInteger.ZERO ) )
   this.coeffs.remove(i);
 }

 /** Degree function
  *
  * @return degree of this polynomial.  -1 if zero polynomial
  */
 public int degree() {
  return this.coeffs.size() - 1;
 }

 /** Convert polynomial from string
  *
  * @param s Input string
  * @return This polynomial after the conversion
  */
 public LongIntegerPolynomial fromString(String s) {
  throw new UnsupportedOperationException("Not implemented yet.");
 }

 @Override
 public String toString() { return this.coeffs.toString(); }

 public List< LongInteger > coefficients() { return this.coeffs; }
 
 public boolean equals( LongIntegerPolynomial poly ) {
  
  this.ensureLeadingCoefficient();
  poly.ensureLeadingCoefficient();
  
  // Lengths must be the same
  if( this.coeffs.size() != poly.coeffs.size() )
   return false;
  
  // Iterate down lists
  for( int i = 0; i < this.coeffs.size(); ++i ) {
   if( !this.coeffs.get(i).equals( poly.coeffs.get( i ) ) )
    return false;
  }
  
  // Must be equal!
  return true;
  
  //return this.coeffs.equals( poly.coeffs ); // Why doesn't this work?
  
  
 }

 /** Polynomial addition
  *
  * @param poly
  * @return
  */
 public LongIntegerPolynomial add(LongIntegerPolynomial poly) {
  LongIntegerPolynomial returnPoly;
  ArrayList<LongInteger> coeffList= new ArrayList<LongInteger>();
  
  ArrayList<LongInteger> thisCoeffList = this.coeffs;
  ArrayList<LongInteger> polyCoeffList = poly.coeffs;
  
  int size = this.degree();
  if(poly.degree() > size){
      thisCoeffList.addAll(new ArrayList<LongInteger>(Collections.nCopies(poly.degree()-size, LongInteger.valueOf(0))));
      //System.out.println("Padded this list: " + thisCoeffList.toString());
      size = poly.degree();
  }
  else if(poly.degree() < size){
      polyCoeffList.addAll(new ArrayList<LongInteger>(Collections.nCopies(size-poly.degree(), LongInteger.valueOf(0))));
      //System.out.println("Padded poly list: " + polyCoeffList.toString());
  }
  else{
      
  }
  for(int i = 0; i <= size; i++){
      coeffList.add(thisCoeffList.get(i).add(polyCoeffList.get(i)));  
  }
  returnPoly = new LongIntegerPolynomial(coeffList);
   return returnPoly;
 }

 /** Scalar multiplication without modular arithmetic
  * This function is necessary to allow non-modular division, which is
  * necessary to find the remainder during modular arithmetic.
  *
  * @param a Scalar by which to multiply the polynomial
  * @return Polynomial scaled by the scalar
  */
 private LongIntegerPolynomial multiplyNoMod(LongInteger a) {
  throw new UnsupportedOperationException("not yet supported");
 }

 /** Scalar multiplication
  *
  * @param a Scalar by which to multiply the polynomial
  * @return Polynomial scaled by the scalar
  */
 public LongIntegerPolynomial multiply(LongInteger a) {
   ArrayList<LongInteger> returnList = new ArrayList<LongInteger>();
   for(int i = 0; i <= this.degree(); i++){
       returnList.add(this.coeffs.get(i).multiply(a));
   }
   
   return new LongIntegerPolynomial(returnList);
 }

 /** Negation
  *
  * @return This polynomial with all coefficients negated.
  */
 public LongIntegerPolynomial negate() {
//  return this.multiply(LongInteger.ZERO.subtract(LongInteger.ONE));
  LongIntegerPolynomial result = new LongIntegerPolynomial();
  for (int i = 0; i < this.coeffs.size(); ++i) {
   result.coeffs.add(this.coeffs.get(i).negate());
  }

  return result;
 }

 /** Subtration
  *
  * @param poly
  * @return
  */
 public LongIntegerPolynomial subtract(LongIntegerPolynomial poly) {
  return this.add(poly.negate());
 }

 /** Multiplication by another polynomial
  *
  * @param poly
  * @return
  */
 public LongIntegerPolynomial multiply(LongIntegerPolynomial poly) {
   LongIntegerPolynomial accumulator = new LongIntegerPolynomial();
   for(int i = 0; i <= poly.degree(); i++){
       ArrayList<LongInteger> tempList = new ArrayList<LongInteger>();
       tempList.addAll(new ArrayList<LongInteger>(Collections.nCopies(i, LongInteger.valueOf(0))));
       //System.out.println("Multiplying by: " + poly.coeffs.get(i));
       tempList.addAll(this.multiply(poly.coeffs.get(i)).coeffs);
       //System.out.println("Adding: " +tempList);
       accumulator = accumulator.add(new LongIntegerPolynomial(tempList));
   }
   return accumulator;
 }

 public LongInteger leadingCoefficient() {
  this.ensureLeadingCoefficient();
  if( this.coeffs.isEmpty() )
//   return LongInteger.ZERO;
   return LongInteger.ONE;  // Leading unit of zero polyomial is one
  else
   return this.coeffs.get( this.coeffs.size() - 1 );
 }

 /** Multiply this by a power of x
  *
  * @param power
  * @return
  */
 private LongIntegerPolynomial shift( int power ) {
  // Create empty result
  LongIntegerPolynomial result = new LongIntegerPolynomial();

  // Add zeroes for the shift
  for( int k = 0; k < power; ++k )
   result.coeffs.add( LongInteger.ZERO );

  // Now add all the coeffcients of this
  result.coeffs.addAll( this.coeffs );

  // Done
  return result;
 }

 /** Division by another polynomial
  *
  * @param poly
  * @return
  */
 public LongIntegerPolynomial divide(LongIntegerPolynomial poly) {
  if( !LongIntegerPolynomial.modular() )
   return this.divideAndRemainder(poly)[0];
  else
   return this.divideMod(poly);
 }

 /** Remainder after division
  * Does not change this.
  *
  * @param x Other operand
  * @return Result as new LongIntegerPolynomial
  */
 public LongIntegerPolynomial remainder(LongIntegerPolynomial x) {
  return this.divideAndRemainder(x)[1];
 }

 /** Division by another polynomial, returning both the quotient and the remainder.
  *
  * @param poly
  * @return Array with the quotient first and then the remainder
  */
 public LongIntegerPolynomial[] divideAndRemainder(LongIntegerPolynomial poly) {
     //Check for divide by zero error
     if(poly.equals(LongIntegerPolynomial.ZERO)){
         throw new java.lang.ArithmeticException("Divide by zero");
     }
    ArrayList<LongInteger> quotient = new ArrayList<LongInteger>();
    ArrayList<LongInteger> returnDigitList = new ArrayList<LongInteger>(); 
    LongIntegerPolynomial[] returnArray = new LongIntegerPolynomial[2];
    if(this.degree() < poly.degree()){
         //System.out.println("Instant exit");
         returnArray[0] = LongIntegerPolynomial.ZERO;
         returnArray[1] = this;
         return returnArray;
     }
    LongIntegerPolynomial denominator = new LongIntegerPolynomial(poly);
    LongIntegerPolynomial numerator = new LongIntegerPolynomial(this);
    quotient = numerator.coeffs;
    LongInteger denomLeadingDigit = denominator.coeffs.get(poly.degree());
    for(int i = 0; i <= numerator.degree(); i++){
        //System.out.println("\nStart of Loop: " + i);
        //System.out.println("Quotient: " + quotient);
        //LongInteger trialDigit = numLeadingDigit.divide(denomLeadingDigit);
        //System.out.println("Trial Digit: " + trialDigit.toString());
        ArrayList<LongInteger> tempList = new ArrayList<LongInteger>();
        LongInteger trialDigit = quotient.get(quotient.size()-1).divide(denomLeadingDigit);
        //System.out.println("Quotient: " + quotient);
               
        //System.out.println("Quotient: " + quotient);
        tempList.add(trialDigit);
        
        LongIntegerPolynomial trialPoly = new LongIntegerPolynomial(tempList);
        int difference = new LongIntegerPolynomial(quotient).degree() - denominator.degree();
        if(difference < 0){
          break;
        }
        
        trialPoly = trialPoly.shift((new LongIntegerPolynomial(quotient)).degree() - denominator.degree());
        //System.out.println("Denom" + denominator.toString());
        //System.out.println("TrialPoly: " + trialPoly.toString());
        //System.out.println("Multiply denom: " + denominator.multiply(trialPoly).toString());
        
        LongIntegerPolynomial tempQuotient = (new LongIntegerPolynomial(quotient)).subtract(denominator.multiply(trialPoly));
        
        //System.out.println("tempQuo: " + tempQuotient.toString() + "size: " + tempQuotient.degree());
        quotient = tempQuotient.coeffs;
        returnDigitList.add(0, trialDigit);
        if(tempQuotient.degree() < 0){
            break;
        }
    }
    
    returnArray[0] = new LongIntegerPolynomial(returnDigitList);
    //System.out.println("ReturnDigitList" + returnArray[0].toString());
    
    returnArray[1] = new LongIntegerPolynomial(quotient);
    return returnArray;
 }

 /** Multiplicative inverse
  * Does not change this.
  *
  * @return Result as new LongIntegerPolynomial
  */
 public LongIntegerPolynomial inverse() {
  throw new UnsupportedOperationException("not yet supported");
 }
 
 /** The traditional Extended Euclidean Algorithm.
  * Computes the GCD and corresponding coefficients of this and x via the
  * traditional algorithm and returns an array of three LongIntegers.
  * [0] is a GCD
  * [1] is the coefficient corresponding to this
  * [2] is the coefficient corresponding to x
  *
  * @param x
  * @return
  */
 public LongIntegerPolynomial[] traditionalEEA( LongIntegerPolynomial x ) {
  throw new UnsupportedOperationException("not yet supported");
 }

 /** The Extended Euclidean Algorithm.
  * Computes the GCD and corresponding coefficients of this and x via the
  * Extended Euclidean algorithm and returns an array of three LongIntegers.
  * [0] is the GCD
  * [1] is the coefficient corresponding to this
  * [2] is the coefficient corresponding to x
  *
  * @param x
  * @return
  */
 public LongIntegerPolynomial[] EEA( LongIntegerPolynomial x ) {
  throw new UnsupportedOperationException("not yet supported");
 }

 /** Greatest common divisor
  * 
  * @param x
  * @return 
  */
 public LongIntegerPolynomial gcd( LongIntegerPolynomial x ) {
  return this.EEA(x)[0];
 }
 
 /** Modular division
  * Does not change this.
  *
  * @param x Other operand
  * @return Result as new LongInteger
  */
 private LongIntegerPolynomial divideMod(LongIntegerPolynomial x) {
  throw new UnsupportedOperationException("not yet supported");
 }

 /** Raise to a power
  * Does not change this.
  *
  * @param l Power to raise this to 
  * @return Result as new LongIntegerPolynomial
  */
 public LongIntegerPolynomial pow(LongInteger l) {
  throw new UnsupportedOperationException("not yet supported");
 }

 /** Evaluate the polynomial at a value using Horner's rule.
  *
  * @param u
  * @return
  */
 public LongInteger apply( LongInteger u ) {
  throw new UnsupportedOperationException("not yet supported");
 }
 
 /** Evaluate the polynomial at a series of values
  * 
  * @param u Values at which to evaluate the polynomial
  * @return Array of values
  */ 
 public LongInteger[] evaluate( LongInteger[] u ) {
  throw new UnsupportedOperationException("not yet supported");
 }

 /** Lagrange Interpolants
  * 
  * @param u Values at which to create Lagrange Interpolants
  * @return Array of interpolants
  */ 
 public static LongIntegerPolynomial[] lagrangeInterpolants( LongInteger[] u ) {
  throw new UnsupportedOperationException("not yet supported");
 }

 /** Lagrange Interpolating Polynomial
  * 
  * @param u Values at which to interpolate
  * @param v Values function to have at those points
  * @return 
  */ 
 public static LongIntegerPolynomial interpolate( LongInteger[] u, LongInteger[] v  ) {
  throw new UnsupportedOperationException("not yet supported");
 }

 /** Chinese Remainder Algorithm
  * 
  * @param v Array of values at moduli
  * @param m Array of moduli
  * @return 
  */ 
 public static LongIntegerPolynomial cra( LongIntegerPolynomial[] v, LongIntegerPolynomial[] m ) {
  throw new UnsupportedOperationException("not yet supported");
 }

 /** Multiply by LongIntegerPolynomialPolynomial poly via Karatsuba algorithm
  * 
  * @param poly Other operand
  * @return Result as new LongIntegerPolynomial
  */ 
 public LongIntegerPolynomial karatsuba( LongIntegerPolynomial poly ) {
  throw new UnsupportedOperationException("not yet supported");
 }

 /** Reversal of polynomial 
  * Assume k >= degree of this
  * 
  * @param k degree of the reversal
  * @return 
  */
 public LongIntegerPolynomial reversal( int k ) {
  throw new UnsupportedOperationException("not yet supported");
 }
 
 /** Inversion of the polynomial via Newton iteration
  * Computes the inverse modulo a power of x
  * Requires the constant term to be one
  * 
  * @param k the power of the modulus
  * @return 
  */
 public LongIntegerPolynomial inversion( int l ) {
  throw new UnsupportedOperationException("not yet supported");
 }
 
 
 /** Fast division with remainder via Newton iteration
  * 
  * @param poly Other operand
  * @return Result as a new LongIntegerPolynomial
  */
 public LongIntegerPolynomial[] fastDivideAndRemainder( LongIntegerPolynomial poly ) {
  throw new UnsupportedOperationException("not yet supported");
 }
 
 /** p-adic inversion using Newton iteration.
  * Invert this modulo p^l given a starting solution g0
  * 
  * @param p an arbitrary LongIntegerPolynomial
  * @param l a power of p
  * @param g0 the inverse of this modulo p
  * @return 
  */
 public LongIntegerPolynomial inversion( LongIntegerPolynomial p, int l, LongIntegerPolynomial g0 ) {
  throw new UnsupportedOperationException("not yet supported");
 }

 /** Formal derivative
  * 
  * @return 
  */
 public LongIntegerPolynomial derivative() {
  throw new UnsupportedOperationException("not yet supported");
 }
 
 /** p-adic Newton iteration.
  * Find a root of this modulo p^l
  * 
  * @param p an arbitrary LongInteger
  * @param l a power of p
  * @param g0 an initial solution: a root modulo p
  * @param s0 the inverse of the derivative of this evaluated at g0 modulo p
  * @return 
  */
// public LongInteger newton( LongInteger p, int l, LongInteger g0, LongInteger s0 ) {
// }
 
 /** Compute minimal generating polynomial of a sequence given the beginning 
  * of the sequence.  Here we assume enough entries of the sequence are given
  * to determine the minimal generating polynomial.
  * 
  * @param a The beginning of the linearly recurrent sequence
  * @return minimal generating polynomial of the sequence
  */
 public static LongIntegerPolynomial minpoly( List<LongInteger> a ) {
  throw new UnsupportedOperationException("not yet supported");
 }

}
